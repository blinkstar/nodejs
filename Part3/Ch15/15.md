# 第15章 用 TLS/SSL 保证服务器的安全性

## 本章提要：

* 理解公钥基础结构是如何工作的
* 创建 TLS 服务器
* 连接 TLS 服务器
* 验证服务器和客户端证书
* 安全地收发数据

传输层安全 (Transport Layer Security, TLS) 和安全套接字层 (Secure Socket Layer, SSL) 允许客户端/服务器应用程序以阻止
窃听 (其他人看到你的消息) 和篡改 (别人修改你的消息) 的方式通过网络进行通信。TLS/SSL 会在 **传输层** 上对网络连接进行加密，
这使得隐私和消息都能得到验证。

TLS 是基于  NetScape 公司开发的早期 SSL 规范，实际上，TLS 1.0 也被称为 SSL 3.1 ，而最新版的 TLS (TLS 1.2) 也被称为 SSL 3.3 。
本章将用 TLS 代替遭轻视的 SSL 命名法。

## 15.1 理解私钥和公钥

公钥加密是指需要两个独立密钥的加密系统，一个密钥用来加密明文，另一个密钥解密已加密的消息。其中一个密钥是公有的，另一个是私有的，如果
明文使用公钥加密，那么只能用私钥对其进行解密，这可以使公钥拥有者和私钥拥有者进行私有通信。如果明文是用私钥加密的，那么公钥就可以对其
进行解密，在这种情况下，系统会验证私钥拥有者在文档上的签名。

公钥证书\(也被称作数字证书\)使用数字签名绑定公钥和身份信息 -- 个人或者是组织。文档会由认证中心进行签名，认证中心会完成验证匹配公钥的
身份信息的过程。认证中心会响应其他证书，无论这个证书是自签名的还是由其他认证中心签名的，这样就会形成一个授权链，这个授权链是公钥
基础结构的一部分。

每台计算机都会定义一组根认证中心，在默认情况下用它们来验证认证和认证链。在使用 Node 的 TLS 库时，可以使用这些默认的认证中心或者
自定义的认证中心。

### 15.1.1 产生私钥

注意：Node 中的 TLS 是基于 OpenSSL 库实现的，可能你已经安装了这个库，为了检查安装与否，需要打开一个终端并尝试使用 openssl 命令，如果
OpenSSL 库没有安装，就要查找 openssl 包并安装。

TLS 依赖于公钥/私钥基础结构，在这个基础结构中，每个客户端和服务器都必须有一个私钥对消息签名。openssl 实用程序可以在命令行上创建私钥，
如下所示：

    $ openssl genrsa -out my_key.pem 1024

上述命令创建了一个文件 my_key.pem ，也即私钥。

### 15.1.2 产生公钥

涉及 TLS 的服务器和客户端在彼此验证时必须具有一个证书，证书是由认证中心签名或者自签名的公钥。获取证书的第一步是创建一个证书签发请求
(Certificate Signing Request, CSR) 文件，如下所示：

    $ openssl req -new -key my_key.pem -out my_csr.pem

上述命令会创建一个 CSR 文件 my_csr.pem ,但首先你必须回答几个由 openssl 提出的身份认证问题。

为了用 CSR 创建自签名的证书，可以如下所示：

    $ openssl x509 -req -in my_csr.pem -signkey my_key.pem -out my_cert.pem

上述命令会在私钥和认证请求的基础上创建一个自签名文件 my_cert.pem 。另一种方法是将 CSR 发送到认证中心进行签名，但是对于研究本章中的
示例而言，自签名认证已经足够了。

## 15.2 构建 TLS 服务器

TLS 服务器是 net.Server 的子集，在第10章 "构建TCP服务器" 中我已经介绍过 net.Server 。能用 net.Server 创建什么，就能用 TLS 创建
什么。但是，在使用 TLS 服务器时，使用的是安全的连接。

### 15.2.1 初始化服务器

初始化 TLS 服务器比初始化普通的 TCP 服务器要稍微复杂一些，因为必须传入服务器的**私钥**和**证书文件**：

    var tls = require('tls');
    var fs = require('fs');

    var serverOptions = {
        key: fs.readFileSync('./my_key.pem'),
        cert: fs.readFileSync('./my_certificate.pem');
    };

    var server = tls.createServer(serverOptions);

在上面的代码中，用到了 **同步版本** 的 fs.readFile ，它会将文件全部读入内存，来获取文件系统上的密钥和证书。

注意：在上面的代码中用到了 fs.readFileSync ，这是一个同步函数，这不会阻塞事件循环吗？不是，它只是在 Node 的初始化阶段执行，此时事件
循环还没有开始。只有不是在事件处理程序中使用阻塞函数，就不会阻塞事件循环。

但是等等，如果这是一个写入数据的模块，而某些人在回调函数中请求该模块会怎么样？不应该在回调函数内部请求模块，这些模块会进行同步的文件系统
访问，这样就会阻塞事件循环。

除了 key 选项和 cert 选项外，tls.createServer 还可以接受如下所示的选项：
* requestCert -- 如果为 true ，服务器就会请求连接到其上的客户端的证书，并且会尝试对证书进行验证。默认值是 false 。
* rejectUnauthorized -- 如果为 true ，服务器会使用一个认证中心的列表来拒绝任何未经授权的连接。该选项只在 requestCert 为 true 时起
  作用。默认值是false 。

### 15.2.2 监听连接

与简单的 TCP 服务器一样，可以将 TLS 服务器绑定到 TCP 端口，如下所示：

    var port = 4001;
    server.listen(port);

当有新的连接到达时，服务器会发射 secureConnection 事件，并将其传入套接字来注册回调函数：

    function connectionListener(stream){
        console.log('got a new connection');
    }

    server.on('secureConnection', connectionListener);

### 15.2.3 从客户端读取数据

当有客户端连接时，服务器会发射 secureConnection 事件，并将 tls.CleartextStream 类的实例传入回调函数。与 net.Socket 对象很相似，
tls.CleartextStream 对象实现了一个双向流接口，这意味着所有可读流、可写流以及流的事件都可为你所用，只需要绑定 data 事件来获取客户端
发送的未加密数据即可，如下所示：

    function secureConnectionListener(clientStream){
        clientStream.on('data', function(data){
            console.log('got some data from the client:' + data);
        });
    }
    server.on('secureConnection', secureConnectionListener);

### 15.2.4 向客户端发送数据

还可以使用 CleartextStream 对象向连接到服务器上的客户端发送数据，如下所示：

    server.on('secureConnection', function(clientStream){
        clientStream.write('Hey Hello!\n');
    });

### 15.2.5 终止连接

只要调用客户端流上的 .end() 函数就可以终止安全连接，例如，如果客户端输入了 "quit"，就可以终止连接，如下所示：

    server.on('secureConnection', function(clientStream){
        clientStream.on('data', function(data){
            if(data.toString().trim().toLowerCase() === 'quit'){
                clientStream.end('Bye bye!');
            }
        });
    });

与 TCP 下的情况一样，可以将一个字符串或者缓冲区传入 clientStream.end 函数，它们将在连接关闭前最后被发送到客户端。
